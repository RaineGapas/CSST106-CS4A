# -*- coding: utf-8 -*-
"""MP1_CSST106.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GT7zkxzEhfzIUTsDxZN8LrGNE_plDQ_Z

Import Libraries
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import cv2
import os
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dense, Flatten, Dropout
from tensorflow.keras.models import Sequential
from tensorflow.keras.preprocessing.image import ImageDataGenerator

"""Load the real and forged signature datasets"""

real_path = '/content/drive/MyDrive/dataset/orininal dataset'
forge_path = '/content/drive/MyDrive/dataset/fraud dataset'

real_images = []
for img_name in os.listdir(real_path):
    img = cv2.imread(os.path.join(real_path, img_name), cv2.IMREAD_GRAYSCALE)
    real_images.append(img)
real_images = np.array(real_images, dtype=object)

forge_images = []
for img_name in os.listdir(forge_path):
    img = cv2.imread(os.path.join(forge_path, img_name), cv2.IMREAD_GRAYSCALE)
    forge_images.append(img)
forge_images = np.array(forge_images, dtype=object)

"""Spliting the Training and Testing Images"""

real_labels = np.zeros(real_images.shape[0])
forge_labels = np.ones(forge_images.shape[0])

X = np.concatenate((real_images, forge_images), axis=0)
y = np.concatenate((real_labels, forge_labels), axis=0)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""Loading the Data and Normalizing it"""

import cv2
import numpy as np

# load the dataset
real_path = '/content/drive/MyDrive/dataset/orininal dataset'
forge_path = '/content/drive/MyDrive/dataset/fraud dataset'

# set the image size to 128x128
img_size = (128, 128)

real_images = []
for img_name in os.listdir(real_path):
    img = cv2.imread(os.path.join(real_path, img_name), cv2.IMREAD_GRAYSCALE)
    img = cv2.resize(img, img_size)
    real_images.append(img)
real_images = np.array(real_images)

forge_images = []
for img_name in os.listdir(forge_path):
    img = cv2.imread(os.path.join(forge_path, img_name), cv2.IMREAD_GRAYSCALE)
    img = cv2.resize(img, img_size)
    forge_images.append(img)
forge_images = np.array(forge_images)

# normalize the data
real_images = real_images.astype('float32') / 255.0
forge_images = forge_images.astype('float32') / 255.0

"""Create labels for the real and forged signatures"""

import numpy as np

num_real_images = len(real_images)
num_forge_images = len(forge_images)

# Create labels for the real and forged signatures
real_labels = np.zeros(num_real_images, dtype=int)
forge_labels = np.ones(num_forge_images, dtype=int)

# Concatenate the real and forged images and labels
X = np.concatenate((real_images, forge_images), axis=0)
y = np.concatenate((real_labels, forge_labels), axis=0)

"""Reshaping the Training Set"""

import numpy as np

# create dummy data
X_train = np.random.rand(40, 128, 128)

# add another dimension to the array
X_train = np.expand_dims(X_train, axis=-1)

# reshape the array
X_train = X_train.reshape(X_train.shape[0], 128, 128, 1)

print(X_train.shape)  # output: (40, 128, 128, 1)

"""Reshaping the Test Set"""

import numpy as np

# create dummy data
X_test = np.random.rand(40, 128, 128)

# add another dimension to the array
X_test = np.expand_dims(X_test, axis=-1)

# reshape the array
X_test = X_train.reshape(X_test.shape[0], 128, 128, 1)

print(X_train.shape)  # output: (40, 128, 128, 1)

"""Making the CNN model"""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

# Create a Sequential model
model = Sequential()

# Add a convolutional layer
model.add(Conv2D(filters=32, kernel_size=(3,3), activation='relu', input_shape=(128, 128, 1)))

# Add a max pooling layer
model.add(MaxPooling2D(pool_size=(2,2)))

# Add another convolutional layer
model.add(Conv2D(filters=64, kernel_size=(3,3), activation='relu'))

# Add another max pooling layer
model.add(MaxPooling2D(pool_size=(2,2)))

# Flatten the output from the convolutional layers
model.add(Flatten())

# Add a fully connected layer with 128 neurons and a relu activation function
model.add(Dense(units=128, activation='relu'))

# Add a dropout layer to reduce overfitting
model.add(Dropout(rate=0.5))

# Add the output layer with a sigmoid activation function
model.add(Dense(units=1, activation='sigmoid'))

# Print a summary of the model architecture
model.summary()

"""Evaluating the Mode"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

history = model.fit(X_train, y_train, batch_size=32, epochs=10, validation_data=(X_test, y_test))

"""Testing Loss and Accuracy"""

test_loss, test_acc = model.evaluate(X_test, y_test)
print("Test accuracy:", test_acc)
print("Test loss:", test_loss)

"""Detection of Real and Forged Signature"""

# Load a signature image
# You can change the image path and check if it is forged or real
img = cv2.imread('/content/drive/MyDrive/dataset/orininal dataset/agh1_1.jpg', cv2.IMREAD_GRAYSCALE)
img = cv2.resize(img, (128, 128))
img = np.array(img).reshape(1, 128, 128, 1) / 255.0

# Predict the class of the signature image
prediction = model.predict(img)

if prediction < 0.5:
    print("The signature is real.")
else:
    print("The signature is forged.")